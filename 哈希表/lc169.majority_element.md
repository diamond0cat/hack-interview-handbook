

* 摩尔投票法（Boyer–Moore majority vote algorithm），也被称作「多数投票法」，算法解决的问题是：如何在任意多的候选人中（选票无序），选出获得票数最多的那个。

* 算法可以分为两个阶段：

* 对抗阶段：分属两个候选人的票数进行两两对抗抵消
* 计数阶段：计算对抗结果中最后留下的候选人票数是否有效


* method 1:哈希表计数

```java
class Solution {
    public int majorityElement(int[] nums) {
        int size = nums.length;
        Map<Integer, Integer> freq = new HashMap<>();
        for (int num : nums) {
            int count = freq.getOrDefault(num, 0);
            if (count +1 > size / 2) return num;
            freq.put(num, count + 1);

        }
        return Integer.MIN_VALUE;
    }
```


* method 2: 排序
* 既然数组中有出现次数> ⌊ n/2 ⌋的元素，那排好序之后的数组中，相同元素总是相邻的。
* 即存在长度> ⌊ n/2 ⌋的一长串 由相同元素构成的连续子数组。
* 举个例子：
* 无论是1 1 1 2 3，0 1 1 1 2还是-1 0 1 1 1，数组中间的元素总是“多数元素”，毕竟它长度> ⌊ n/2 ⌋。


```java

    public int majorityElement(int[] nums) {
        int len = nums.length;
        Arrays.sort(nums);
        return nums[len / 2];
    }
```

* method 3: 
* 摩尔投票法思路
* 候选人(cand_num)初始化为nums[0]，票数count初始化为1。
* 当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。
* 当票数count为0时，更换候选人，并将票数count重置为1。
* 遍历完数组后，cand_num即为最终答案。

* 为何这行得通呢？
* 投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。
* 且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。
* 因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。
* 这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。

* 无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。


```java
    public int majorityElement(int[] nums) {
        int candid = nums[0], count = 1;
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == candid) count++;
            else count--;
            
            if (count == 0) {
                candid = nums[i];
                count = 1;
            }
        }
        return candid;
    }
```